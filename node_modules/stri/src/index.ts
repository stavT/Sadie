import { ObjSpread } from "obj-spread";


type str = string;




export class Stri {
    /**
     * you don`t even need it - just import this module and all funcs now available inside basic string class
     * @returns 
     */
    static includeMe() {
        return ``;
    }

    /**
     * fast way to cut away a last part split by smth, for instance
     * `"lalala/hahaha/bebebe".cutLast('/')` will return `"lalala/hahaha"`
     * @param	splitter
     */
    static cutLast(s: str, splitter: str): str {
        // console.log(`STRI: cutting last of ${s} by ${splitter}`);

        if (!s.has(splitter)) return s;
        const arr = s.split(splitter || ``);
        arr.pop();
        return arr.join(splitter);
    }
    /**
     * fast way to cut away a first part split by smth, for instance
     * `"lalala/hahaha/bebebe".cutFirst('/')` will return `"hahaha/bebebe"`
     * @param	splitter
     */
    static cutFirst(s: str, splitter: str): str {
        if (!s.has(splitter)) return s;
        const arr = s.split(splitter || ``);
        arr.shift();
        return arr.join(splitter);
    }
    /**
     * fast way to get the last part split by smth, for instance
     * `"lalala/hahaha/bebebe".getLast('/')` will return `"bebebe"`
     * @param	splitter
     */
    static getLast(s: str, splitter: str): str {
        if (!s.has(splitter)) return s;
        return s.split(splitter || ``).pop()!;
    }
    /**
     * fast way get the first part split by smth, for instance
     * `"lalala/hahaha/bebebe".getFirst('/')` will return `"lalala"`
     * @param	splitter
     */
    static getFirst(s: str, splitter: str): str {
        if (!s.has(splitter)) return s;
        return s.split(splitter || ``).shift()!;
    }
    /**
     * Replaces `from` with `to`
     * @param from what to replace
     * @param to to what to replace
     */
    static swap(s: str, from: str, to: str) { return s?.split(from || ``).join(to); }
    /**
     * does this string contain `what`?
     * @param what 
     * @returns 
     */
    static has(s: str, what: string) { return s?.indexOf(what) != -1; }

    /**
     * returns string between borderA and B. Gets between the first A and the LAST B
     * @param	borderA
     * @param	borderB
     */
    static getBetween(s: str, borderA: str, borderB: str): str {
        return s.between(borderA, borderB, true, false);
    }

    /**
     * returns string between borderA and B. Gets between the FIRST A and the FIRST B
     * @param	borderA
     * @param	borderB
     */
    static getBetweenClose(s: str, borderA: str, borderB: str): str {
        return s.between(borderA, borderB, true, true);
    }




    /**
     * returns string between borders
     * @param	borderA - left border
     * @param	borderB - right border
     * @param aIsFirst - true if borderA is first, false if is last
     * @param bIsFirst - true if borderB is first, false if is last
     */
    static between(s: str, borderA: str, borderB: str, aIsFirst: boolean, bIsFirst: boolean): str {
        if (s.has(borderA) && s.has(borderB)) {
            const r = aIsFirst ? s.cutFirst(borderA) : s.getLast(borderA);
            return bIsFirst ? r?.getFirst(borderB) : r?.cutLast(borderB);
        }
        else return ``;
    }
    /**
     * Removes all `what`s in the string
     * In fact, same as `str.split(what).join('')`
     * @param what what to remove
     * @returns 
     */
    static oust(s: str, what: str) {
        if (!s) return ``;
        if (!s.has(what)) return s;
        return s.swap(what, ``);
    }


}

try {
    if (typeof <any>(String.prototype).cutFirst == `undefined`)
        new ObjSpread(Stri, String, s => String(s));
} catch (e) {

}

declare global {
    export interface String {
        cutLast(splitter: str): str;
        cutFirst(splitter: str): str;
        getLast(splitter: str): str;
        getFirst(splitter: str): str;
        swap(what: str, withWhat: str): str;
        has(what: str): boolean;
        oust(what: str): string;
        getBetween(borderA: str, borderB: str): str;
        getBetweenClose(borderA: str, borderB: str): str;
        between(borderA: str, borderB: str, aIsFirst: boolean, bIsFirst: boolean): str;
    }
}

